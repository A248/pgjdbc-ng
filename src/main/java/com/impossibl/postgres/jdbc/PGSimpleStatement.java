package com.impossibl.postgres.jdbc;

import static com.impossibl.postgres.jdbc.ErrorUtils.chainWarnings;
import static com.impossibl.postgres.jdbc.Exceptions.INVALID_COMMAND_FOR_GENERATED_KEYS;
import static com.impossibl.postgres.jdbc.Exceptions.NOT_SUPPORTED;
import static com.impossibl.postgres.jdbc.SQLTextUtils.appendReturningClause;
import static com.impossibl.postgres.jdbc.SQLTextUtils.getProtocolSQLText;
import static java.util.Arrays.asList;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.util.Collections;

import com.impossibl.postgres.protocol.PrepareCommand;
import com.impossibl.postgres.protocol.ResultField;
import com.impossibl.postgres.types.Type;

class PGSimpleStatement extends PGStatement {

	public PGSimpleStatement(PGConnection connection, int type, int concurrency, int holdability) {
		super(connection, type, concurrency, holdability, null, Collections.<ResultField>emptyList());
	}

	SQLWarning prepare(String sql) throws SQLException {
		
		sql = getProtocolSQLText(sql);

		PrepareCommand prep = connection.getProtocol().createPrepare(null, sql, Collections.<Type>emptyList());
		
		SQLWarning warningChain = connection.execute(prep);
		
		resultFields = prep.getDescribedResultFields();
		
		return warningChain;
	}
	
	@Override
	public boolean execute(String sql) throws SQLException {
		
		SQLWarning prepWarningChain = prepare(sql);
				
		boolean res = super.executeStatement(null, Collections.<Type>emptyList(), Collections.<Object>emptyList());
		
		warningChain = chainWarnings(prepWarningChain, warningChain);
		
		return res;
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {

		if(autoGeneratedKeys != RETURN_GENERATED_KEYS) {
			return execute(sql);
		}
		
		sql = appendReturningClause(sql);
		if(sql == null) {
			throw INVALID_COMMAND_FOR_GENERATED_KEYS;
		}
		
		execute(sql);
		
		generatedKeysResultSet = getResultSet();
		
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {

		throw NOT_SUPPORTED;
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		
		sql = appendReturningClause(sql, asList(columnNames));
		if(sql == null) {
			throw INVALID_COMMAND_FOR_GENERATED_KEYS;
		}
		
		execute(sql);
		
		generatedKeysResultSet = getResultSet();
		
		return false;
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {

		execute(sql);

		return getResultSet();
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		
		execute(sql);
		
		return getUpdateCount();
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		
		execute(sql, autoGeneratedKeys);
		
		return getUpdateCount();
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {

		execute(sql, columnIndexes);
		
		return getUpdateCount();
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {

		execute(sql, columnNames);
		
		return getUpdateCount();
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		throw NOT_SUPPORTED;
	}

	@Override
	public void clearBatch() throws SQLException {
		throw NOT_SUPPORTED;
	}

	@Override
	public int[] executeBatch() throws SQLException {
		throw NOT_SUPPORTED;
	}

}
